# COMP3004 Final Exam Notes

## Software engineering

### What is it?

- requirements analysis
- building a software system to accomplish a task
    - a software system is big and complex
    - not just a dinky little program
- reliable, modifiable process

### Why is it necessary?

- huge systems and projects difficult to manage
- we need a plan
- reliability, modifiability






## Build models

- functional model

- dynamic model

- object model

### Why do we need them?

- get an idea of full system
- requirements
- clarify details
- make sure client and design team on the same page

### What are they?

- functional model
    - FR, NFR (table, FURPS+)
    - use cases (diagrams, tables)
        - high level (don't forget the box!)
        - detailed (includes and extends)
- dynamic model
    - state machine diagrams(s)
    - activity diagram(s)
    - sequence diagram(s)
- object model
    - class diagram(s)
    - data dictionaries

### Traceability -- what and why?

- number entries in tables for traceability
    - esp. FR/NFR and data dictionary
- helps with maintenance of design








## Software development life cycle

### Phases and work products of each

### Requirements elicitation

### Analysis

### High-level system design

### Detailed object design

### Implementation

### Testing

### Deployment and maintenance









## Models in requirements analysis

### Object model

### Dynamic model

### Functional model











## Requirements elicitation

### Why do it?

### FR and NFR (FURPS+)

### Scenarios and use cases

### UML use case diagrams

### Use case tables








## Analysis

### Object model

### Dynamic model








## High level design

### Design goals

### Subsystem decomposition

### System design strategies







## Detailed object design

### Types of inheritance

### Liskov's principle

### Contracts







## Implementation

### Mapping objects to collections

### Model transformations

### Mapping associations to collections

### Mapping associations to storage

### Buried associations

### Association tables

### Vertical/horizontal mapping of inheritance to storage







## Testing

### Blackbox vs whitebox

### Unit testing (path, equivalence, boundary, state, polymorphism)

### Integration testing (top-down, bottom-up, sandwich, modified sandwich, test stubs, test drivers)

### System testing (functional, performance)






## Software development life cycle model

### Agile

### Waterfall

### V-model

### Spiral








## Ethics

### Professionalism

### Code of ethics

### Process for making ethical decisions
